<?xml version = "1.0"?>

<unit>
	<title>Unit 3: XML and Ajax</title>
	<section>
		<sectiontitle>What is XML?</sectiontitle>
		<paragraph>XML is short for Extensible Markup Language which is used to describe and format data to be exchanged between aplications over the internet. XML is a widely supported open technology. One factor that contributes to this is that document authors can create markup on any types of information making it extremely versitle. In addition XML is both human and machine readable which has definitely helped on its adoption rate. XMLs are case sensitive and require a XML parser to make the document's data available to applications. A XML document that follows correct syntax is called a well-formed XML document. This requires a single root element, properly nested tags with a start and end tag for each element.
		</paragraph>
	</section>
	<section>
		<sectiontitle>Validating XML Documents</sectiontitle>
		<paragraph>As we have mentioned above, a well-formed XML document can follow the correct syntax and similar to any program, can compile and run. However, the result of this program may be incorrect. This is similarly known in a XML. If a XML document is valid, but does not contain correctly formatted data, it is known as not valid. To validate XML documents by an external format style - for example making sure there is always a phonenumber tag in the correct place - there are two options: Document Type Definition (DTD) and schema. These are called validating parsers which check if an XML document follows the correct structure. Therefore it is possible that an XML document is well-formed, but is not valid.
		</paragraph>
		<paragraph>Document Type Definition (DTD) files are expressed using an EBNF (Extended Backus-Naur Form). In DTD files there are two main definitions to declare. These are the ELEMENT and ATTLIST definitions, which as their name implies defines rules for an element and attribute list. An example of them are &#60;!ELEMENT name ( #PCDATA )&#62; and &#60;!ATTLIST name ( #CDATA )&#62;. The elements called PCDATA and CDATA are known as parsed character data and character data respectively. Character data will pass data without modification, whereas parsed character data will be processed by the XML parser - meaning characters cannot contain markup characters. These types however do not check against character types such as int or string. This is problem is solved in schemas.
		</paragraph>
		<paragraph>Schemas are definitely more flexible than DTDs as DTDs lacked type checks on data. As well DTDs require developers to learn different types of grammers which can take away from the readability that XMLs provide. Schema documents are easy to pick up as they use XML syntax which developers greatly appreciate. In a Schema document, you define namespaces that will match the XML document. Then you can define complex and simple types within the schema. Simple types cannot contain attribute or child elements whereas complex types can. However complex types that contain simple content must extend or restrict some other existing type. In a Schema, you are able to define elements with these types to create the structure you wish to obtain. In addition a sequence of elements can be defined using the sequence start and end tags.
		</paragraph>
	</section>
	<section>
		<sectiontitle>Extensible Stylesheet Language and XSL Transformation</sectiontitle>
		<paragraph>Extensible Stylesheet Language (XSL) documents are a group of 3 technologies XSL-FO (XSL Formatting Objects), XPath (XML Path language) and XSLT (XSL Transformations). XSL-FO handles formatting, XPath handles efficient and effective structure and data locating by the means of a string-based language of expressions, and XSLT is the transformation of XML documents to other documents. XSL is extremely useful converting XML documents to HTML5 documents where the information can be displayed. XSLT involves tree structures where nodes are taken and transformed from the source tree (XML document) to the result tree (result tree).
		</paragraph>
		<paragraph>XSL documents are denoted by their extension of .xsl. XSL documents require XSL stylesheet start and end tags. An example of this is &#60;xsl-stylesheet version = "1.0" xmlns:xsl = "http:&#47;&#47;www.w3.org&#47;1999&#47;XSL&#47;Transform"&#62;content&#60;&#47;xsl:stylesheet&#62;. These tags are used to define that this document is an XSL file. The xsl namespace is used to bind the prefix xsl to W3C XSLT URI. As well the &#60;?xml version = "1.0"?&#62; is still required at the top of the document.
		</paragraph>
		<paragraph>Now althought you have defined a XSL document, you still need to define the output method and doctype of the XSL document. This is done within the xsl-stylesheet tags with the following denotation &#60;xsl:output method = "html" doctype-system = "about:legacy-compat"&#47;&#62;. Then you will define the initial template match that the XSL will use throughout the document. This is denoted with the &#60;xsl:template match = "&#47;"&#62;content&#60;&#47;xsl:template&#62;.After defining how the output of the document will go, you are able to write up your HTML5 document as regular. In areas where you need dynamic data from the XML file you are able to use XSL definitions such as &#60;xsl:value-of select = "name"&#47;&#62; to select specific properties of the source tree based on the tag name. Another definition is the for-each instead of the value-of which cycles through each source tree node at the given source tree location.
		</paragraph>
	</section>
	<section>
		<sectiontitle>Asynchronous JavaScript and XML and Rich Internet Applications</sectiontitle>
		<paragraph>Although the Internet has grown drastically over the past while, it was not as always as fast as we known it to be today. Web Applications often fell behind in usability in comparsion to desktop applications. During this time, web applications were bottlenecked by synchronous requests and transactions to the server. This meant when a user interacted with something that required server processing, they essentially needed to wait until the request was met with a response. This would require the user to reload the entire page with the data from the reponse. This was often critized as the "brochure web" as a web full of hyptertext documents. 
		</paragraph>
		<paragraph>In a solution to this, Rich Internet Applications (RIAs) were invented to approximate the look, feel, and usability of desktop applications. Rich Internet Applications have two key attributes - performance and a rich GUI (Graphic User Interface). RIAs are largely contributed by Asynchronous JavaScript and XML or Ajax for short. Ajax separates the client-side and server-side so they can run in parallel. This greatly improves performance with the assistance of client-side scripting to make web applications more responsive and reducing the delays of server-side processing. This way, when the user receives a response from the server, the client does not need to wait and can do other things on their side. In addition, the client-side does not need to always refresh the page when data is received from the server making it have a similar feel to desktop applications.
		</paragraph>
		<paragraph>So how does JavaScript manage interactions with the server? This is commonly handled by the XMLHttpRequest object - XHR. In a more detailed explaination, when the user interacts with the page that requires a response from the server, a XMLHttpRequest object is created with the correct request. This request is asynchronous and is send off with the correct information it needs to entail a response. Since this request is asynchronous, the user can continue interacting with the application. Once the request is received from the server, a response is generated and the XMLHttpRequest object that was created earlier now needs to be processed by the client. A function known as a callback function is used for partial page updates and define how the request will be processed. Once the data is processed, the application can update the page. Multiple requests can be handled and requested concurrently creating a RIA.
		</paragraph>
	</section>
</unit>

<quiz>
	<question>
		<inquiry>XML is short for...</inquiry>
		<answer correct = "">Extendable Markup Language</answer>
		<answer correct = "">Extreme Mathematic Language</answer>
		<answer correct = "*">Extensible Markup Language</answer>
		<answer correct = "">Xenon Markup language</answer>
	</question>
	<question>
		<inquiry>Which of the following is correct?</inquiry>
		<answer correct = "">Document Type Definitions can check against character types</answer>
		<answer correct = "">Schemas are less flexible than DTDs</answer>
		<answer correct = "">Document Type Definitions are expressed using XML language</answer>
		<answer correct = "*">An XML document may be well-formed, but not valid</answer>
	</question>
	<question>
		<inquiry>Extensible Stylesheet Language is made of what 3 technologies?</inquiry>
		<answer correct = "">XSL-FO, XPath, and XSL-FA</answer>
		<answer correct = "">XSL-FO, XPath, and XSLT</answer>
		<answer correct = "">XSL-FA, XPath, and XSLT</answer>
		<answer correct = "*">Schema, XPath, and XSLT</answer>
	</question>
	<question>
		<inquiry>Which of the following objects are used by JavaScript to handle requests to servers?</inquiry>
		<answer correct = "">Connection</answer>
		<answer correct = "">SchemaHttpRequest</answer>
		<answer correct = "*">XMLHttpRequest</answer>
		<answer correct = "">XMLConnectionRequest</answer>
	</question>
	<question>
		<inquiry>What are the two key components in Ajax?</inquiry>
		<answer correct = "">JavaScript and DTDs</answer>
		<answer correct = "*">JavaScript and XML</answer>
		<answer correct = "">RIA and a rich GUI</answer>
		<answer correct = "">XML and a rich GUI</answer>
	</question>
</quiz>